"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = void 0;
const session_1 = require("../sessions/session");
const scroll_1 = require("./execute/scroll");
const wait_1 = require("./execute/wait");
const assertions_1 = require("./assertions");
const app_1 = require("./../ios/app");
const bluebird_1 = __importDefault(require("bluebird"));
const flutterCommandRegex = /^[\s]*flutter[\s]*:(.+)/;
// Extract command handlers into a separate object for better organization
const commandHandlers = {
    launchApp: async (driver, appId, opts = {}) => {
        const { arguments: args = [], environment: env = {} } = opts;
        await (0, app_1.launchApp)(driver.internalCaps.udid, appId, args, env);
        await session_1.reConnectFlutterDriver.bind(driver)(driver.internalCaps);
    },
    connectObservatoryWsUrl: async (driver) => {
        await session_1.reConnectFlutterDriver.bind(driver)(driver.internalCaps);
    },
    checkHealth: async (driver) => (await driver.executeElementCommand('get_health')).status,
    getVMInfo: async (driver) => await driver.executeGetVMCommand(),
    getRenderTree: async (driver) => (await driver.executeElementCommand('get_render_tree')).tree,
    getOffset: async (driver, elementBase64, options) => await driver.executeElementCommand('get_offset', elementBase64, options),
    waitForCondition: async (driver, conditionName) => await driver.executeElementCommand('waitForCondition', '', { conditionName }),
    forceGC: async (driver) => {
        const response = await driver.socket.call('_collectAllGarbage', {
            isolateId: driver.socket.isolateId,
        });
        if (response.type !== 'Success') {
            throw new Error(`Could not forceGC, response was ${JSON.stringify(response)}`);
        }
    },
    setIsolateId: async (driver, isolateId) => {
        driver.socket.isolateId = isolateId;
        return await driver.socket.call('getIsolate', { isolateId });
    },
    getIsolate: async (driver, isolateId) => await driver.executeGetIsolateCommand(isolateId || driver.socket.isolateId),
    clearTimeline: async (driver) => {
        const call1 = driver.socket.call('_clearVMTimeline');
        const call2 = driver.socket.call('clearVMTimeline');
        const response = await bluebird_1.default.any([call1, call2]);
        if (response.type !== 'Success') {
            throw new Error(`Could not clear timeline, response was ${JSON.stringify(response)}`);
        }
    },
    getRenderObjectDiagnostics: async (driver, elementBase64, opts = {}) => {
        const { subtreeDepth = 0, includeProperties = true } = opts;
        return await driver.executeElementCommand('get_diagnostics_tree', elementBase64, {
            diagnosticsType: 'renderObject',
            includeProperties,
            subtreeDepth,
        });
    },
    getWidgetDiagnostics: async (driver, elementBase64, opts = {}) => {
        const { subtreeDepth = 0, includeProperties = true } = opts;
        return await driver.executeElementCommand('get_diagnostics_tree', elementBase64, {
            diagnosticsType: 'widget',
            includeProperties,
            subtreeDepth,
        });
    },
    getSemanticsId: async (driver, elementBase64) => (await driver.executeElementCommand('get_semantics_id', elementBase64)).id,
    waitForAbsent: async (driver, finder, timeout) => await (0, wait_1.waitForAbsent)(driver, finder, timeout),
    waitFor: async (driver, finder, timeout) => await (0, wait_1.waitFor)(driver, finder, timeout),
    waitForTappable: async (driver, finder, timeout) => await (0, wait_1.waitForTappable)(driver, finder, timeout),
    scroll: async (driver, finder, opts) => await (0, scroll_1.scroll)(driver, finder, opts),
    scrollUntilVisible: async (driver, finder, opts) => await (0, scroll_1.scrollUntilVisible)(driver, finder, opts),
    scrollUntilTapable: async (driver, finder, opts) => await (0, scroll_1.scrollUntilTapable)(driver, finder, opts),
    scrollIntoView: async (driver, finder, opts) => await (0, scroll_1.scrollIntoView)(driver, finder, opts),
    setTextEntryEmulation: async (driver, enabled) => await driver.socket.executeSocketCommand({ command: 'set_text_entry_emulation', enabled }),
    enterText: async (driver, text) => await driver.socket.executeSocketCommand({ command: 'enter_text', text }),
    requestData: async (driver, message) => await driver.socket.executeSocketCommand({ command: 'request_data', message }),
    longTap: async (driver, finder, durationOrOptions) => await (0, scroll_1.longTap)(driver, finder, durationOrOptions),
    waitForFirstFrame: async (driver) => await driver.executeElementCommand('waitForCondition', '', { conditionName: 'FirstFrameRasterizedCondition' }),
    setFrameSync: async (driver, enabled, durationMilliseconds) => await driver.socket.executeSocketCommand({
        command: 'set_frame_sync',
        enabled,
        timeout: durationMilliseconds,
    }),
    clickElement: async (driver, finder, opts = {}) => {
        const { timeout = 1000 } = opts;
        return await driver.executeElementCommand('tap', finder, { timeout });
    },
    dragAndDropWithCommandExtension: async (driver, params) => await driver.socket.executeSocketCommand({
        command: 'dragAndDropWithCommandExtension',
        ...params,
    }),
    assertVisible: async (driver, input, timeout = 5000) => await (0, assertions_1.assertVisible)(driver, input, timeout),
    assertNotVisible: async (driver, input, timeout = 5000) => await (0, assertions_1.assertNotVisible)(driver, input, timeout),
    assertTappable: async (driver, input, timeout = 5000) => await (0, assertions_1.assertTappable)(driver, input, timeout),
    getTextWithCommandExtension: async (driver, params) => await driver.socket.executeSocketCommand({
        command: 'getTextWithCommandExtension',
        findBy: params.findBy,
    }),
};
const execute = async function (rawCommand, args) {
    const matching = rawCommand.match(flutterCommandRegex);
    if (!matching) {
        throw new Error(`Command not supported: "${rawCommand}"`);
    }
    const command = matching[1].trim();
    const handler = commandHandlers[command];
    if (!handler) {
        throw new Error(`Command not supported: "${rawCommand}"`);
    }
    return await handler(this, ...args);
};
exports.execute = execute;
//# sourceMappingURL=execute.js.map